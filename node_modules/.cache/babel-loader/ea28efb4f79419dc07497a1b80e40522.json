{"ast":null,"code":"import _slicedToArray from\"/Users/rhendren/walleye_sms/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";import _objectSpread from\"/Users/rhendren/walleye_sms/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread2\";import{useReducer,useEffect,useRef}from\"react\";import firebase from\"./firebase\";var firestore=firebase.firestore();/**** USERS ****/ // Fetch user data (hook)\n// This is called automatically by auth.js and merged into auth.user\nexport function useUser(uid){return useQuery(uid&&firestore.collection(\"users\").doc(uid));}// Update an existing user\nexport function updateUser(uid,data){return firestore.collection(\"users\").doc(uid).update(data);}// Create a new user\nexport function createUser(uid,data){return firestore.collection(\"users\").doc(uid).set(_objectSpread({uid:uid},data),{merge:true});}/**** ITEMS ****/ /* Example query functions (modify to your needs) */ // Fetch all items by owner (hook)\nexport function useItemsByOwner(owner){return useQuery(owner&&firestore.collection(\"items\").where(\"owner\",\"==\",owner));}// Fetch item data\nexport function useItem(id){return useQuery(id&&firestore.collection(\"items\").doc(id));}// Update an item\nexport function updateItem(id,data){return firestore.collection(\"items\").doc(id).update(data);}// Create a new item\nexport function createItem(data){return firestore.collection(\"items\").add(data);}/**** HELPERS ****/ // Reducer for useQuery hook state and actions\nvar reducer=function reducer(state,action){switch(action.type){case\"idle\":return{status:\"idle\",data:undefined,error:undefined};case\"loading\":return{status:\"loading\",data:undefined,error:undefined};case\"success\":return{status:\"success\",data:action.payload,error:undefined};case\"error\":return{status:\"error\",data:undefined,error:action.payload};default:throw new Error(\"invalid action\");}};// Custom React hook that subscribes to a Firestore query\nfunction useQuery(query){// Our initial state\n// Start with an \"idle\" status if query is falsy, as that means hook consumer is\n// waiting on required data before creating the query object.\n// Example: useQuery(uid && firestore.collection(\"profiles\").doc(uid))\nvar initialState={status:query?\"loading\":\"idle\",data:undefined,error:undefined};// Setup our state and actions\nvar _useReducer=useReducer(reducer,initialState),_useReducer2=_slicedToArray(_useReducer,2),state=_useReducer2[0],dispatch=_useReducer2[1];// Gives us previous query object if query is the same, ensuring\n// we don't trigger useEffect on every render due to query technically\n// being a new object reference on every render.\nvar queryCached=useMemoCompare(query,function(prevQuery){// Use built-in Firestore isEqual method to determine if \"equal\"\nreturn prevQuery&&query&&query.isEqual(prevQuery);});useEffect(function(){// Return early if query is falsy and reset to \"idle\" status in case\n// we're coming from \"success\" or \"error\" status due to query change.\nif(!queryCached){dispatch({type:\"idle\"});return;}dispatch({type:\"loading\"});// Subscribe to query with onSnapshot\n// Will unsubscribe on cleanup since this returns an unsubscribe function\nreturn queryCached.onSnapshot(function(response){// Get data for collection or doc\nvar data=response.docs?getCollectionData(response):getDocData(response);dispatch({type:\"success\",payload:data});},function(error){dispatch({type:\"error\",payload:error});});},[queryCached]);// Only run effect if queryCached changes\nreturn state;}// Get doc data and merge doc.id\nfunction getDocData(doc){return doc.exists===true?_objectSpread({id:doc.id},doc.data()):null;}// Get array of doc data from collection\nfunction getCollectionData(collection){return collection.docs.map(getDocData);}// Used by useQuery to store Firestore query object reference\nfunction useMemoCompare(next,compare){// Ref for storing previous value\nvar previousRef=useRef();var previous=previousRef.current;// Pass previous and next value to compare function\n// to determine whether to consider them equal.\nvar isEqual=compare(previous,next);// If not equal update previousRef to next value.\n// We only update if not equal so that this hook continues to return\n// the same old value if compare keeps returning true.\nuseEffect(function(){if(!isEqual){previousRef.current=next;}});// Finally, if equal then return the previous value\nreturn isEqual?previous:next;}","map":{"version":3,"sources":["/Users/rhendren/walleye_sms/src/util/db.js"],"names":["useReducer","useEffect","useRef","firebase","firestore","useUser","uid","useQuery","collection","doc","updateUser","data","update","createUser","set","merge","useItemsByOwner","owner","where","useItem","id","updateItem","createItem","add","reducer","state","action","type","status","undefined","error","payload","Error","query","initialState","dispatch","queryCached","useMemoCompare","prevQuery","isEqual","onSnapshot","response","docs","getCollectionData","getDocData","exists","map","next","compare","previousRef","previous","current"],"mappings":"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","sourcesContent":["import { useReducer, useEffect, useRef } from \"react\";\nimport firebase from \"./firebase\";\n\nconst firestore = firebase.firestore();\n\n/**** USERS ****/\n\n// Fetch user data (hook)\n// This is called automatically by auth.js and merged into auth.user\nexport function useUser(uid) {\n  return useQuery(uid && firestore.collection(\"users\").doc(uid));\n}\n\n// Update an existing user\nexport function updateUser(uid, data) {\n  return firestore.collection(\"users\").doc(uid).update(data);\n}\n\n// Create a new user\nexport function createUser(uid, data) {\n  return firestore\n    .collection(\"users\")\n    .doc(uid)\n    .set({ uid, ...data }, { merge: true });\n}\n\n/**** ITEMS ****/\n/* Example query functions (modify to your needs) */\n\n// Fetch all items by owner (hook)\nexport function useItemsByOwner(owner) {\n  return useQuery(\n    owner && firestore.collection(\"items\").where(\"owner\", \"==\", owner)\n  );\n}\n\n// Fetch item data\nexport function useItem(id) {\n  return useQuery(id && firestore.collection(\"items\").doc(id));\n}\n\n// Update an item\nexport function updateItem(id, data) {\n  return firestore.collection(\"items\").doc(id).update(data);\n}\n\n// Create a new item\nexport function createItem(data) {\n  return firestore.collection(\"items\").add(data);\n}\n\n/**** HELPERS ****/\n\n// Reducer for useQuery hook state and actions\nconst reducer = (state, action) => {\n  switch (action.type) {\n    case \"idle\":\n      return { status: \"idle\", data: undefined, error: undefined };\n    case \"loading\":\n      return { status: \"loading\", data: undefined, error: undefined };\n    case \"success\":\n      return { status: \"success\", data: action.payload, error: undefined };\n    case \"error\":\n      return { status: \"error\", data: undefined, error: action.payload };\n    default:\n      throw new Error(\"invalid action\");\n  }\n};\n\n// Custom React hook that subscribes to a Firestore query\nfunction useQuery(query) {\n  // Our initial state\n  // Start with an \"idle\" status if query is falsy, as that means hook consumer is\n  // waiting on required data before creating the query object.\n  // Example: useQuery(uid && firestore.collection(\"profiles\").doc(uid))\n  const initialState = {\n    status: query ? \"loading\" : \"idle\",\n    data: undefined,\n    error: undefined,\n  };\n\n  // Setup our state and actions\n  const [state, dispatch] = useReducer(reducer, initialState);\n\n  // Gives us previous query object if query is the same, ensuring\n  // we don't trigger useEffect on every render due to query technically\n  // being a new object reference on every render.\n  const queryCached = useMemoCompare(query, (prevQuery) => {\n    // Use built-in Firestore isEqual method to determine if \"equal\"\n    return prevQuery && query && query.isEqual(prevQuery);\n  });\n\n  useEffect(() => {\n    // Return early if query is falsy and reset to \"idle\" status in case\n    // we're coming from \"success\" or \"error\" status due to query change.\n    if (!queryCached) {\n      dispatch({ type: \"idle\" });\n      return;\n    }\n\n    dispatch({ type: \"loading\" });\n\n    // Subscribe to query with onSnapshot\n    // Will unsubscribe on cleanup since this returns an unsubscribe function\n    return queryCached.onSnapshot(\n      (response) => {\n        // Get data for collection or doc\n        const data = response.docs\n          ? getCollectionData(response)\n          : getDocData(response);\n\n        dispatch({ type: \"success\", payload: data });\n      },\n      (error) => {\n        dispatch({ type: \"error\", payload: error });\n      }\n    );\n  }, [queryCached]); // Only run effect if queryCached changes\n\n  return state;\n}\n\n// Get doc data and merge doc.id\nfunction getDocData(doc) {\n  return doc.exists === true ? { id: doc.id, ...doc.data() } : null;\n}\n\n// Get array of doc data from collection\nfunction getCollectionData(collection) {\n  return collection.docs.map(getDocData);\n}\n\n// Used by useQuery to store Firestore query object reference\nfunction useMemoCompare(next, compare) {\n  // Ref for storing previous value\n  const previousRef = useRef();\n  const previous = previousRef.current;\n\n  // Pass previous and next value to compare function\n  // to determine whether to consider them equal.\n  const isEqual = compare(previous, next);\n\n  // If not equal update previousRef to next value.\n  // We only update if not equal so that this hook continues to return\n  // the same old value if compare keeps returning true.\n  useEffect(() => {\n    if (!isEqual) {\n      previousRef.current = next;\n    }\n  });\n\n  // Finally, if equal then return the previous value\n  return isEqual ? previous : next;\n}\n"]},"metadata":{},"sourceType":"module"}