{"ast":null,"code":"import { useReducer, useEffect, useRef } from \"react\";\nimport firebase from \"./firebase\";\nconst firestore = firebase.firestore();\n/**** USERS ****/\n// Fetch user data (hook)\n// This is called automatically by auth.js and merged into auth.user\n\nexport function useUser(uid) {\n  return useQuery(uid && firestore.collection(\"users\").doc(uid));\n} // Update an existing user\n\nexport function updateUser(uid, data) {\n  return firestore.collection(\"users\").doc(uid).update(data);\n} // Create a new user\n\nexport function createUser(uid, data) {\n  return firestore.collection(\"users\").doc(uid).set({\n    uid,\n    ...data\n  }, {\n    merge: true\n  });\n}\n/**** ITEMS ****/\n\n/* Example query functions (modify to your needs) */\n// Fetch all items by owner (hook)\n\nexport function useItemsByOwner(owner) {\n  return useQuery(owner && firestore.collection(\"items\").where(\"owner\", \"==\", owner));\n} // Fetch item data\n\nexport function useItem(id) {\n  return useQuery(id && firestore.collection(\"items\").doc(id));\n} // Update an item\n\nexport function updateItem(id, data) {\n  return firestore.collection(\"items\").doc(id).update(data);\n} // Create a new item\n\nexport function createItem(data) {\n  return firestore.collection(\"items\").add(data);\n}\n/**** HELPERS ****/\n// Reducer for useQuery hook state and actions\n\nconst reducer = (state, action) => {\n  switch (action.type) {\n    case \"idle\":\n      return {\n        status: \"idle\",\n        data: undefined,\n        error: undefined\n      };\n\n    case \"loading\":\n      return {\n        status: \"loading\",\n        data: undefined,\n        error: undefined\n      };\n\n    case \"success\":\n      return {\n        status: \"success\",\n        data: action.payload,\n        error: undefined\n      };\n\n    case \"error\":\n      return {\n        status: \"error\",\n        data: undefined,\n        error: action.payload\n      };\n\n    default:\n      throw new Error(\"invalid action\");\n  }\n}; // Custom React hook that subscribes to a Firestore query\n\n\nfunction useQuery(query) {\n  // Our initial state\n  // Start with an \"idle\" status if query is falsy, as that means hook consumer is\n  // waiting on required data before creating the query object.\n  // Example: useQuery(uid && firestore.collection(\"profiles\").doc(uid))\n  const initialState = {\n    status: query ? \"loading\" : \"idle\",\n    data: undefined,\n    error: undefined\n  }; // Setup our state and actions\n\n  const [state, dispatch] = useReducer(reducer, initialState); // Gives us previous query object if query is the same, ensuring\n  // we don't trigger useEffect on every render due to query technically\n  // being a new object reference on every render.\n\n  const queryCached = useMemoCompare(query, prevQuery => {\n    // Use built-in Firestore isEqual method to determine if \"equal\"\n    return prevQuery && query && query.isEqual(prevQuery);\n  });\n  useEffect(() => {\n    // Return early if query is falsy and reset to \"idle\" status in case\n    // we're coming from \"success\" or \"error\" status due to query change.\n    if (!queryCached) {\n      dispatch({\n        type: \"idle\"\n      });\n      return;\n    }\n\n    dispatch({\n      type: \"loading\"\n    }); // Subscribe to query with onSnapshot\n    // Will unsubscribe on cleanup since this returns an unsubscribe function\n\n    return queryCached.onSnapshot(response => {\n      // Get data for collection or doc\n      const data = response.docs ? getCollectionData(response) : getDocData(response);\n      dispatch({\n        type: \"success\",\n        payload: data\n      });\n    }, error => {\n      dispatch({\n        type: \"error\",\n        payload: error\n      });\n    });\n  }, [queryCached]); // Only run effect if queryCached changes\n\n  return state;\n} // Get doc data and merge doc.id\n\n\nfunction getDocData(doc) {\n  return doc.exists === true ? {\n    id: doc.id,\n    ...doc.data()\n  } : null;\n} // Get array of doc data from collection\n\n\nfunction getCollectionData(collection) {\n  return collection.docs.map(getDocData);\n} // Used by useQuery to store Firestore query object reference\n\n\nfunction useMemoCompare(next, compare) {\n  // Ref for storing previous value\n  const previousRef = useRef();\n  const previous = previousRef.current; // Pass previous and next value to compare function\n  // to determine whether to consider them equal.\n\n  const isEqual = compare(previous, next); // If not equal update previousRef to next value.\n  // We only update if not equal so that this hook continues to return\n  // the same old value if compare keeps returning true.\n\n  useEffect(() => {\n    if (!isEqual) {\n      previousRef.current = next;\n    }\n  }); // Finally, if equal then return the previous value\n\n  return isEqual ? previous : next;\n}","map":{"version":3,"sources":["/Users/rhendren/walleye_sms/src/util/db.js"],"names":["useReducer","useEffect","useRef","firebase","firestore","useUser","uid","useQuery","collection","doc","updateUser","data","update","createUser","set","merge","useItemsByOwner","owner","where","useItem","id","updateItem","createItem","add","reducer","state","action","type","status","undefined","error","payload","Error","query","initialState","dispatch","queryCached","useMemoCompare","prevQuery","isEqual","onSnapshot","response","docs","getCollectionData","getDocData","exists","map","next","compare","previousRef","previous","current"],"mappings":"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","sourcesContent":["import { useReducer, useEffect, useRef } from \"react\";\nimport firebase from \"./firebase\";\n\nconst firestore = firebase.firestore();\n\n/**** USERS ****/\n\n// Fetch user data (hook)\n// This is called automatically by auth.js and merged into auth.user\nexport function useUser(uid) {\n  return useQuery(uid && firestore.collection(\"users\").doc(uid));\n}\n\n// Update an existing user\nexport function updateUser(uid, data) {\n  return firestore.collection(\"users\").doc(uid).update(data);\n}\n\n// Create a new user\nexport function createUser(uid, data) {\n  return firestore\n    .collection(\"users\")\n    .doc(uid)\n    .set({ uid, ...data }, { merge: true });\n}\n\n/**** ITEMS ****/\n/* Example query functions (modify to your needs) */\n\n// Fetch all items by owner (hook)\nexport function useItemsByOwner(owner) {\n  return useQuery(\n    owner && firestore.collection(\"items\").where(\"owner\", \"==\", owner)\n  );\n}\n\n// Fetch item data\nexport function useItem(id) {\n  return useQuery(id && firestore.collection(\"items\").doc(id));\n}\n\n// Update an item\nexport function updateItem(id, data) {\n  return firestore.collection(\"items\").doc(id).update(data);\n}\n\n// Create a new item\nexport function createItem(data) {\n  return firestore.collection(\"items\").add(data);\n}\n\n/**** HELPERS ****/\n\n// Reducer for useQuery hook state and actions\nconst reducer = (state, action) => {\n  switch (action.type) {\n    case \"idle\":\n      return { status: \"idle\", data: undefined, error: undefined };\n    case \"loading\":\n      return { status: \"loading\", data: undefined, error: undefined };\n    case \"success\":\n      return { status: \"success\", data: action.payload, error: undefined };\n    case \"error\":\n      return { status: \"error\", data: undefined, error: action.payload };\n    default:\n      throw new Error(\"invalid action\");\n  }\n};\n\n// Custom React hook that subscribes to a Firestore query\nfunction useQuery(query) {\n  // Our initial state\n  // Start with an \"idle\" status if query is falsy, as that means hook consumer is\n  // waiting on required data before creating the query object.\n  // Example: useQuery(uid && firestore.collection(\"profiles\").doc(uid))\n  const initialState = {\n    status: query ? \"loading\" : \"idle\",\n    data: undefined,\n    error: undefined,\n  };\n\n  // Setup our state and actions\n  const [state, dispatch] = useReducer(reducer, initialState);\n\n  // Gives us previous query object if query is the same, ensuring\n  // we don't trigger useEffect on every render due to query technically\n  // being a new object reference on every render.\n  const queryCached = useMemoCompare(query, (prevQuery) => {\n    // Use built-in Firestore isEqual method to determine if \"equal\"\n    return prevQuery && query && query.isEqual(prevQuery);\n  });\n\n  useEffect(() => {\n    // Return early if query is falsy and reset to \"idle\" status in case\n    // we're coming from \"success\" or \"error\" status due to query change.\n    if (!queryCached) {\n      dispatch({ type: \"idle\" });\n      return;\n    }\n\n    dispatch({ type: \"loading\" });\n\n    // Subscribe to query with onSnapshot\n    // Will unsubscribe on cleanup since this returns an unsubscribe function\n    return queryCached.onSnapshot(\n      (response) => {\n        // Get data for collection or doc\n        const data = response.docs\n          ? getCollectionData(response)\n          : getDocData(response);\n\n        dispatch({ type: \"success\", payload: data });\n      },\n      (error) => {\n        dispatch({ type: \"error\", payload: error });\n      }\n    );\n  }, [queryCached]); // Only run effect if queryCached changes\n\n  return state;\n}\n\n// Get doc data and merge doc.id\nfunction getDocData(doc) {\n  return doc.exists === true ? { id: doc.id, ...doc.data() } : null;\n}\n\n// Get array of doc data from collection\nfunction getCollectionData(collection) {\n  return collection.docs.map(getDocData);\n}\n\n// Used by useQuery to store Firestore query object reference\nfunction useMemoCompare(next, compare) {\n  // Ref for storing previous value\n  const previousRef = useRef();\n  const previous = previousRef.current;\n\n  // Pass previous and next value to compare function\n  // to determine whether to consider them equal.\n  const isEqual = compare(previous, next);\n\n  // If not equal update previousRef to next value.\n  // We only update if not equal so that this hook continues to return\n  // the same old value if compare keeps returning true.\n  useEffect(() => {\n    if (!isEqual) {\n      previousRef.current = next;\n    }\n  });\n\n  // Finally, if equal then return the previous value\n  return isEqual ? previous : next;\n}\n"]},"metadata":{},"sourceType":"module"}